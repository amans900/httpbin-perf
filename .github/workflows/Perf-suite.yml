name: perf-suite

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  jmeter-matrix:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - scenario: smoke
            threads: 50
            rampup: 30
            duration: 60
          - scenario: load
            threads: 100
            rampup: 60
            duration: 180
          - scenario: stress
            threads: 300
            rampup: 60
            duration: 120
          - scenario: spike
            threads: 200
            rampup: 10
            duration: 60
          - scenario: soak
            threads: 50
            rampup: 30
            duration: 900

    env:
      # Grafana endpoint exposed by docker compose
      GRAFANA_URL: http://localhost:3000
      # Use the exact URLs you use locally;
      # we will extract uid/slug/orgId and resolve safely inside CI.
      GRAFANA_JMETER_URL: http://localhost:3000/d/JMeterOverview/jmeter-overview?orgId=1
      GRAFANA_CAD_URL:    http://localhost:3000/d/container-metrics/container-metrics-cadvisor?orgId=1
      # Titles used as a last-resort match in search:
      GRAFANA_JMETER_TITLE: JMeter Overview
      GRAFANA_CAD_TITLE:    Container Metrics (cAdvisor)

      GRAFANA_AUTH: admin:admin
      GRAFANA_ORGID_DEFAULT: "1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Start minimal infra (httpbin + monitoring + grafana)
        run: |
          set -eux
          docker compose up -d influxdb httpbin grafana renderer loki promtail prometheus cadvisor
          # Wait until Grafana is healthy
          for i in {1..60}; do
            curl -fsS "${GRAFANA_URL}/api/health" >/dev/null && break || sleep 2
          done

      - name: Build JMeter image (5.6.3)
        run: docker build -t jmeter:5.6.3 ./jmeter/docker

      - name: Run ${{ matrix.scenario }} (CSV JTL + HTML report)
        id: run_test
        run: |
          set -eux
          SCEN=${{ matrix.scenario }}
          ROOT=jmeter/results
          OUT="$ROOT/$SCEN"
          CSV_JTL="$ROOT/${SCEN}.csv"
          mkdir -p "$OUT"
          rm -f "$CSV_JTL" || true
          rm -rf "$OUT/html" || true

          START_MS=$(( $(date -u +%s) * 1000 ))
          echo "start_ms=${START_MS}" >> "$GITHUB_OUTPUT"

          set +e
          docker run --rm --network host \
            -e JVM_ARGS="-Djava.awt.headless=true -Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" \
            -v "$GITHUB_WORKSPACE/jmeter:/jmeter" -w /jmeter jmeter:5.6.3 \
            -n -t testplans/httpbin_load.jmx \
            -Jthreads=${{ matrix.threads }} \
            -Jrampup=${{ matrix.rampup }} \
            -Jduration=${{ matrix.duration }} \
            -Jscenario_name=$SCEN \
            -Jtarget_host=localhost -Jtarget_port=8080 \
            -Jjmeter.save.saveservice.output_format=csv \
            -Jjmeter.save.saveservice.print_field_names=true \
            -Jjmeter.save.saveservice.default_delimiter=, \
            -Jjmeter.save.saveservice.timestamp_format=ms \
            -Jjmeter.save.saveservice.data_type=true \
            -Jjmeter.save.saveservice.label=true \
            -Jjmeter.save.saveservice.response_code=true \
            -Jjmeter.save.saveservice.response_message=true \
            -Jjmeter.save.saveservice.thread_name=true \
            -Jjmeter.save.saveservice.successful=true \
            -Jjmeter.save.saveservice.failure_message=true \
            -Jjmeter.save.saveservice.bytes=true \
            -Jjmeter.save.saveservice.sent_bytes=true \
            -Jjmeter.save.saveservice.grp_threads=true \
            -Jjmeter.save.saveservice.all_threads=true \
            -Jjmeter.save.saveservice.url=true \
            -Jjmeter.save.saveservice.latency=true \
            -Jjmeter.save.saveservice.idle_time=true \
            -Jjmeter.save.saveservice.connect_time=true \
            -l "results/${SCEN}.csv" \
            -j "results/${SCEN}/jmeter.log" \
            -e -o "results/${SCEN}/html"
          EXIT=$?
          set -e

          echo "JMeter exit (info): $EXIT"
          head -n 1 "$CSV_JTL" || true
          test -f "$OUT/html/index.html" && echo "HTML OK" || echo "HTML MISSING"

      - name: Render Grafana panels (${{ matrix.scenario }})
        if: always()
        run: |
          set -eux
          SCEN=${{ matrix.scenario }}
          OUT_DIR="jmeter/results/${SCEN}/grafana"
          mkdir -p "${OUT_DIR}"

          FROM_MS="${{ steps.run_test.outputs.start_ms }}"
          TO_MS=$(( $(date -u +%s) * 1000 ))
          AUTH_FLAG="-u ${GRAFANA_AUTH}"

          # ---------- helpers ----------
          # Parse: /d/<uid>/<slug>?orgId=N  ->  uid slug orgId
          parse_uid_slug_org () {
            local url="$1"
            local rest="${url#*/d/}"               # <uid>/<slug>?...
            local path="${rest%%\?*}"              # <uid>/<slug>
            local uid="${path%%/*}"
            local slug="${path#*/}"
            local q="${rest#*\?}"
            local org="$(echo "$q" | sed -n -E 's/.*(^|&)orgId=([^&]+).*/\2/p')"
            [ -z "$org" ] && org="${GRAFANA_ORGID_DEFAULT}"
            echo "$uid" "$slug" "$org"
          }

          wait_grafana () {
            for i in {1..60}; do
              curl -fsS "${GRAFANA_URL}/api/health" >/dev/null && return 0 || sleep 2
            done
            echo "ERROR: Grafana API not ready" >&2; return 1
          }

          # Wait for a dashboard UID to exist (provisioning can lag)
          wait_dash_by_uid () {
            local uid="$1"
            for i in {1..60}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" ${AUTH_FLAG} "${GRAFANA_URL}/api/dashboards/uid/${uid}")
              [ "$code" = "200" ] && return 0
              sleep 2
            done
            return 1
          }

          # Try to import a dashboard JSON if it exists locally
          import_dash_if_present () {
            local slug="$1"
            # try common locations/names
            for f in "grafana/dashboards/${slug}.json" "grafana/dashboards/${slug%%-*}.json"; do
              if [ -f "$f" ]; then
                echo "Importing dashboard from $f"
                payload=$(jq -c '{dashboard: ., overwrite: true}' "$f")
                curl -fsS ${AUTH_FLAG} -H "Content-Type: application/json" \
                  -X POST -d "$payload" "${GRAFANA_URL}/api/dashboards/db" >/dev/null || true
                return 0
              fi
            done
            return 1
          }

          # Resolve the current UID in this Grafana:
          # 1) try direct UID; if 404, 2) full search and match by uid OR slug OR exact title
          resolve_uid () {
            local want_uid="$1" want_slug="$2" want_title="$3"
            if curl -fsS ${AUTH_FLAG} "${GRAFANA_URL}/api/dashboards/uid/${want_uid}" -o /tmp/d.json; then
              local got_uid slug_api
              got_uid="$(jq -r '.dashboard.uid' /tmp/d.json)"
              slug_api="$(jq -r '.meta.slug // (.dashboard.slug // empty)' /tmp/d.json)"
              [ -z "$slug_api" ] && slug_api="$(jq -r '.meta.url // ""' /tmp/d.json | awk -F/ '{print $NF}')"
              rm -f /tmp/d.json
              echo "$got_uid" "${slug_api:-$want_slug}"
              return 0
            fi
            local res; res="$(curl -fsS ${AUTH_FLAG} "${GRAFANA_URL}/api/search?type=dash-db&limit=5000")"
            local uid url
            uid="$(echo "$res" | jq -r '
              map(select(
                   (.uid=="'"$want_uid"'")
                or (.url|endswith("/'"$want_slug"'"))
                or (.title=="'"$want_title"'")
                or (.slug=="'"$want_slug"'")
              )) | .[0].uid // empty')"
            url="$(echo "$res" | jq -r '
              map(select(
                   (.uid=="'"$want_uid"'")
                or (.url|endswith("/'"$want_slug"'"))
                or (.title=="'"$want_title"'")
                or (.slug=="'"$want_slug"'")
              )) | .[0].url // empty')"
            [ -z "$uid" ] && return 1
            echo "$uid" "${url##*/}"
          }

          list_panels () {
            local uid="$1"
            curl -fsSL ${AUTH_FLAG} "${GRAFANA_URL}/api/dashboards/uid/${uid}" \
              | jq -r '
                  .dashboard
                  | .. | objects
                  | select(has("id") and has("title"))
                  | select(.type != "row")
                  | "\(.id)\t\(.title)"'
          }

          render_panel () {
            local uid="$1" slug="$2" org="$3" pid="$4" title="$5"
            local base="$(echo "$title" | tr -cs '[:alnum:]_-' '_' | sed 's/_\+/_/g;s/^_//;s/_$//')"
            local out="${OUT_DIR}/${uid}_${pid}_${base}.png"
            # try with slug; if that 404s (older Grafana accepts no slug), retry without slug
            curl -fsS ${AUTH_FLAG} \
              "${GRAFANA_URL}/render/d-solo/${uid}/${slug}?orgId=${org}&panelId=${pid}&from=${FROM_MS}&to=${TO_MS}&width=1600&height=800&tz=UTC&theme=dark" \
              -o "${out}" || curl -fsS ${AUTH_FLAG} \
              "${GRAFANA_URL}/render/d-solo/${uid}?orgId=${org}&panelId=${pid}&from=${FROM_MS}&to=${TO_MS}&width=1600&height=800&tz=UTC&theme=dark" \
              -o "${out}" || true
            echo "Saved: ${out}"
          }
          # ---------- /helpers ----------

          wait_grafana

          # parse your URLs
          read JM_UID_URL JM_SLUG_URL JM_ORGID   < <(parse_uid_slug_org "$GRAFANA_JMETER_URL")
          read CAD_UID_URL CAD_SLUG_URL CAD_ORGID < <(parse_uid_slug_org "$GRAFANA_CAD_URL")

          # if direct UID not ready, try import (if JSON exists), then wait/resolve
          for rec in "JM:${JM_UID_URL}:${JM_SLUG_URL}:${JM_ORGID}:JMeter Overview" \
                     "CAD:${CAD_UID_URL}:${CAD_SLUG_URL}:${CAD_ORGID}:Container Metrics (cAdvisor)"; do
            IFS=: read TAG WANT_UID WANT_SLUG ORG TITLE <<<"$rec"
            echo "Preparing ${TAG} (wanted uid=${WANT_UID}, slug=${WANT_SLUG})"
            if ! wait_dash_by_uid "${WANT_UID}"; then
              import_dash_if_present "${WANT_SLUG}" || true
            fi
            # resolve the actual UID+slug that exist *now* in this Grafana
            if read -r REAL_UID REAL_SLUG < <(resolve_uid "${WANT_UID}" "${WANT_SLUG}" "${TITLE}"); then
              echo "${TAG}: resolved uid=${REAL_UID}, slug=${REAL_SLUG}"
            else
              echo "WARN: ${TAG} dashboard not found; skipping"
              continue
            fi
            echo "Rendering ${TAG} panels..."
            list_panels "${REAL_UID}" | while IFS=$'\t' read -r PID PTITLE; do
              echo "  panelId=${PID}  title=${PTITLE}"
              render_panel "${REAL_UID}" "${REAL_SLUG}" "${ORG}" "${PID}" "${PTITLE}"
            done
          done

          ls -l "${OUT_DIR}" || true


      - name: Upload artifacts (${{ matrix.scenario }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: perf-${{ matrix.scenario }}-${{ github.run_id }}-${{ github.run_attempt }}
          retention-days: 30
          if-no-files-found: warn
          path: |
            jmeter/results/${{ matrix.scenario }}/html
            jmeter/results/${{ matrix.scenario }}.csv
            jmeter/results/${{ matrix.scenario }}/jmeter.log
            jmeter/results/${{ matrix.scenario }}/grafana

      - name: Stop stack
        if: always()
        run: docker compose down -v
