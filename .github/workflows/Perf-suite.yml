name: perf-suite

on:
  workflow_dispatch:
  push:
    paths:
      - ".github/workflows/perf-suite.yml"
      - "testplans/**"
      - "grafana/**"
      - "docker-compose.yml"

jobs:
  jmeter-matrix:
    name: jmeter-matrix (${{ matrix.name }}, ${{ matrix.threads }}, ${{ matrix.rampup }}, ${{ matrix.duration }})
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - { name: smoke, threads: 50,  rampup: 30,  duration: 60  }
          - { name: load,  threads: 100, rampup: 60,  duration: 180 }
          - { name: stress,threads: 300, rampup: 60,  duration: 120 }
          - { name: spike, threads: 200, rampup: 10,  duration: 60  }
          - { name: soak,  threads: 50,  rampup: 30,  duration: 900 }

    env:
      JM_VERSION: "5.6.3"
      GRAFANA_URL: "http://localhost:3000"
      # These two must match *how* you open the dashboards in your browser
      GRAFANA_JMETER_URL: "http://localhost:3000/d/JMeterOverview/jmeter-overview?orgId=1"
      GRAFANA_CAD_URL: "http://localhost:3000/d/container-metrics/container-metrics-cadvisor?orgId=1"
      GRAFANA_JMETER_TITLE: "JMeter Overview"
      GRAFANA_CAD_TITLE: "Container Metrics (cAdvisor)"
      GRAFANA_AUTH: "admin:admin"
      GRAFANA_ORGID_DEFAULT: "1"

    steps:
      - name: Set up job
        run: echo "matrix=${{ toJson(matrix) }}"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Mark job start (for Grafana time window)
        id: mark
        shell: bash
        run: |
          echo "JOB_START_MS=$(( $(date -u +%s) * 1000 ))" >> "$GITHUB_ENV"
          echo "Started @ $JOB_START_MS"

      - name: Start stack (httpbin + monitoring + grafana + renderer)
        shell: bash
        run: |
          # write override on-the-fly (renderer + grafana image export)
          cat > docker-compose.override.yml <<'YAML'
          services:
            grafana:
              environment:
                - GF_PANELS_ENABLE_IMAGE_EXPORT=true
                - GF_RENDERING_SERVER_URL=http://renderer:8081/render
                - GF_RENDERING_CALLBACK_URL=http://grafana:3000/
                - GF_LOG_FILTERS=rendering:debug
              # If your base compose uses a different service name than "grafana",
              # change it here to match the base file.
            renderer:
              image: grafana/grafana-image-renderer:3.10.2
              # No published ports needed; Grafana calls it on the compose network.
              environment:
                - ENABLE_METRICS=true
                - RENDERING_MODE=clustered
              depends_on:
                - grafana
          YAML

          docker compose -f docker-compose.yml -f docker-compose.override.yml up -d

          echo "Waiting for Grafana..."
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w '%{http_code}' "$GRAFANA_URL/api/health" || true)
            if [ "$code" = "200" ]; then
              echo "Grafana is healthy"
              break
            fi
            sleep 2
          done

      - name: Install tools
        shell: bash
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Pull JMeter image (${{ env.JM_VERSION }})
        shell: bash
        run: |
          docker pull justb4/jmeter:${JM_VERSION}
          docker tag  justb4/jmeter:${JM_VERSION} jmeter:${JM_VERSION}

      - name: Run ${{ matrix.name }} test (headless: CSV JTL; generate HTML)
        shell: bash
        env:
          SCEN: ${{ matrix.name }}
        run: |
          set -eux
          mkdir -p jmeter/results/${SCEN}

          # Run test
          docker run --rm --network host -v "$PWD/jmeter":/jmeter -w /jmeter \
            jmeter:${JM_VERSION} \
              -n -t testplans/httpbin_load.jmx \
              -Jtarget_host=localhost \
              -Jthreads=${{ matrix.threads }} \
              -Jrampup=${{ matrix.rampup }} \
              -Jduration=${{ matrix.duration }} \
              -Jjmeter.save.saveservice.output_format=csv \
              -l results/${SCEN}/${SCEN}.jtl \
              -j results/${SCEN}/jmeter.log

          # Generate HTML dashboard
          docker run --rm -v "$PWD/jmeter":/jmeter -w /jmeter \
            jmeter:${JM_VERSION} \
              -g results/${SCEN}/${SCEN}.jtl \
              -o results/${SCEN}/html || true

      - name: Render Grafana panels (${{ matrix.name }})
        shell: bash
        env:
          SCEN: ${{ matrix.name }}
        run: |
          set -eux
          OUT_DIR="jmeter/results/${SCEN}/grafana"
          mkdir -p "${OUT_DIR}"

          FROM_MS="${JOB_START_MS}"
          TO_MS=$(( $(date -u +%s) * 1000 ))
          AUTH_FLAG="-u ${GRAFANA_AUTH}"

          parse_uid_slug_org () {
            local url="$1"
            local rest="${url#*/d/}"; local path="${rest%%\?*}"
            local uid="${path%%/*}"; local slug="${path#*/}"
            local q="${rest#*\?}"
            local org="$(echo "$q" | sed -n -E 's/.*(^|&)orgId=([^&]+).*/\2/p')"
            [ -z "$org" ] && org="${GRAFANA_ORGID_DEFAULT}"
            echo "$uid" "$slug" "$org"
          }

          wait_dash_by_uid () {
            local uid="$1"
            for i in {1..60}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" ${AUTH_FLAG} \
                     "${GRAFANA_URL}/api/dashboards/uid/${uid}" || true)
              [ "$code" = "200" ] && return 0
              sleep 2
            done
            return 1
          }

          import_dash_if_present () {
            local slug="$1"
            for f in "grafana/dashboards/${slug}.json" "grafana/dashboards/${slug%%-*}.json"; do
              if [ -f "$f" ]; then
                echo "Importing $f"
                payload=$(jq -c '{dashboard: ., overwrite: true}' "$f")
                curl -fsS ${AUTH_FLAG} -H "Content-Type: application/json" \
                  -X POST -d "$payload" "${GRAFANA_URL}/api/dashboards/db" >/dev/null || true
                return 0
              fi
            done
            return 1
          }

          resolve_uid () {
            local want_uid="$1" want_slug="$2" want_title="$3"
            if curl -fsS ${AUTH_FLAG} "${GRAFANA_URL}/api/dashboards/uid/${want_uid}" -o /tmp/d.json; then
              local got_uid slug_api
              got_uid="$(jq -r '.dashboard.uid' /tmp/d.json)"
              slug_api="$(jq -r '.meta.slug // (.dashboard.slug // empty)' /tmp/d.json)"
              [ -z "$slug_api" ] && slug_api="$(jq -r '.meta.url // ""' /tmp/d.json | awk -F/ '{print $NF}')"
              rm -f /tmp/d.json
              echo "$got_uid" "${slug_api:-$want_slug}"
              return 0
            fi
            local res; res="$(curl -fsS ${AUTH_FLAG} "${GRAFANA_URL}/api/search?type=dash-db&limit=5000")"
            local uid url
            uid="$(echo "$res" | jq -r '
              map(select(
                   (.uid=="'"$want_uid"'")
                or (.url|endswith("/'"$want_slug"'"))
                or (.title=="'"$want_title"'")
                or (.slug=="'"$want_slug"'")
              )) | .[0].uid // empty')"
            url="$(echo "$res" | jq -r '
              map(select(
                   (.uid=="'"$want_uid"'")
                or (.url|endswith("/'"$want_slug"'"))
                or (.title=="'"$want_title"'")
                or (.slug=="'"$want_slug"'")
              )) | .[0].url // empty')"
            [ -z "$uid" ] && return 1
            echo "$uid" "${url##*/}"
          }

          list_panels () {
            local uid="$1"
            curl -fsS ${AUTH_FLAG} "${GRAFANA_URL}/api/dashboards/uid/${uid}" \
              | jq -r '
                  .dashboard
                  | .. | objects
                  | select(has("id") and has("title"))
                  | select(.type != "row")
                  | "\(.id)\t\(.title)"'
          }

          render_panel () {
            local uid="$1" slug="$2" org="$3" pid="$4" title="$5"
            local base="$(echo "$title" | tr -cs '[:alnum:]_-' '_' | sed 's/_\+/_/g;s/^_//;s/_$//')"
            local out="${OUT_DIR}/${uid}_${pid}_${base}.png"

            local url1="${GRAFANA_URL}/render/d-solo/${uid}/${slug}?orgId=${org}&panelId=${pid}&from=${FROM_MS}&to=${TO_MS}&width=1600&height=800&tz=UTC&theme=dark"
            local url2="${GRAFANA_URL}/render/d-solo/${uid}?orgId=${org}&panelId=${pid}&from=${FROM_MS}&to=${TO_MS}&width=1600&height=800&tz=UTC&theme=dark"

            http1=$(curl -sS ${AUTH_FLAG} -w "%{http_code}" -o "${out}.tmp" "${url1}" || echo "000")
            if [ "$http1" != "200" ]; then
              echo "Render 1 failed (${http1}) â€“ trying without slug"
              http2=$(curl -sS ${AUTH_FLAG} -w "%{http_code}" -o "${out}.tmp" "${url2}" || echo "000")
              [ "$http2" != "200" ] && { echo "Render 2 failed (${http2})"; rm -f "${out}.tmp"; return 0; }
            fi
            mv "${out}.tmp" "${out}"
            echo "Saved ${out}"
          }

          read JM_UID JM_SLUG JM_ORG   < <(parse_uid_slug_org "$GRAFANA_JMETER_URL")
          read CAD_UID CAD_SLUG CAD_ORG < <(parse_uid_slug_org "$GRAFANA_CAD_URL")

          for rec in \
            "JM:${JM_UID}:${JM_SLUG}:${JM_ORG}:${GRAFANA_JMETER_TITLE}" \
            "CAD:${CAD_UID}:${CAD_SLUG}:${CAD_ORG}:${GRAFANA_CAD_TITLE}"
          do
            IFS=: read TAG WANT_UID WANT_SLUG ORG TITLE <<<"$rec"
            echo "Prepare ${TAG} want uid=${WANT_UID} slug=${WANT_SLUG}"
            wait_dash_by_uid "${WANT_UID}" || import_dash_if_present "${WANT_SLUG}" || true
            if read -r REAL_UID REAL_SLUG < <(resolve_uid "${WANT_UID}" "${WANT_SLUG}" "${TITLE}"); then
              echo "${TAG} resolved -> ${REAL_UID} / ${REAL_SLUG}"
              list_panels "${REAL_UID}" | while IFS=$'\t' read -r PID PTITLE; do
                render_panel "${REAL_UID}" "${REAL_SLUG}" "${ORG}" "${PID}" "${PTITLE}"
              done
            else
              echo "WARN: ${TAG} not found; skip rendering"
            fi
          done

          ls -l "${OUT_DIR}" || true

      - name: Upload artifacts (${{ matrix.name }})
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ matrix.name }}
          path: jmeter/results/${{ matrix.name }}/
          if-no-files-found: warn
          retention-days: 14

      - name: Stop stack
        if: always()
        shell: bash
        run: |
          docker compose -f docker-compose.yml -f docker-compose.override.yml down -v

      - name: Complete job
        run: echo "Done."
