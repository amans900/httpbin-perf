name: perf-suite

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  # schedule:
  #   - cron: "0 2 * * *"   # optional nightly

jobs:
  jmeter-matrix:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - scenario: smoke
            threads: 50
            rampup: 30
            duration: 60
          - scenario: load
            threads: 100
            rampup: 60
            duration: 180
          - scenario: stress
            threads: 300
            rampup: 60
            duration: 120
          - scenario: spike
            threads: 200
            rampup: 10
            duration: 60
          - scenario: soak
            threads: 50
            rampup: 30
            duration: 300

    env:
      SLA_ERROR_PERCENT: "1.0"   # fail if error% > this

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Start minimal infra (httpbin + monitoring)
        run: |
          set -eux
          docker compose up -d influxdb httpbin grafana loki promtail prometheus cadvisor
          sleep 15
          docker ps

      - name: Build JMeter image (5.6.3)
        run: docker build -t jmeter:5.6.3 ./jmeter/docker

      # ---- Run test AND generate dashboard (force XML); do not fail job here ----
      - name: Run ${{ matrix.scenario }} (headless; XML JTL; generate HTML)
        id: run_test
        run: |
          set -eux
          SCEN=${{ matrix.scenario }}
          ROOT=jmeter/results
          OUT="$ROOT/$SCEN"
          XML_JTL="$ROOT/${SCEN}.xml.jtl"
          CSV_JTL="$ROOT/${SCEN}.jtl"   # if your JMX writes CSV, we keep it for debugging

          # ensure all target folders exist
          mkdir -p "$ROOT" "$OUT"

          rm -f "$XML_JTL" "$CSV_JTL" || true
          rm -rf "$OUT/html" || true

          # Force XML JTL and build dashboard in same process (-e -o)
          set +e
          docker run --rm --network host \
            -e JVM_ARGS="-Djava.awt.headless=true -Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m \
                         -Djmeter.save.saveservice.output_format=xml \
                         -Djmeter.save.saveservice.assertion_results=none" \
            -v "$GITHUB_WORKSPACE/jmeter:/jmeter" -w /jmeter jmeter:5.6.3 \
            -n -t testplans/httpbin_load.jmx \
            -Jthreads=${{ matrix.threads }} \
            -Jrampup=${{ matrix.rampup }} \
            -Jduration=${{ matrix.duration }} \
            -Jscenario_name=$SCEN \
            -Jtarget_host=localhost -Jtarget_port=8080 \
            -l "results/${SCEN}.xml.jtl" \
            -j "results/${SCEN}/jmeter.log" \
            -e -o "results/${SCEN}/html"
          EXIT=$?
          set -e

          echo "JMeter raw exit code: $EXIT"
          echo "First line of XML (if present):"
          head -n 1 "$XML_JTL" || true
          test -f "$OUT/html/index.html" && echo "Dashboard generated." || echo "Dashboard missing."

          # list what we actually have
          ls -l "$ROOT" || true
          ls -l "$OUT" || true

          # store exit code for info (we won't fail on it directly)
          echo "exit_code=$EXIT" >> $GITHUB_OUTPUT

      - name: Upload artifacts (${{ matrix.scenario }})
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jmeter-${{ matrix.scenario }}-artifacts
          retention-days: 30
          if-no-files-found: warn
          path: |
            jmeter/results/${{ matrix.scenario }}/html
            jmeter/results/${{ matrix.scenario }}.xml.jtl
            jmeter/results/${{ matrix.scenario }}.jtl
            jmeter/results/${{ matrix.scenario }}/jmeter.log

      # ---- Evaluate SLAs using XML if available, else fall back to CSV ----
      - name: Evaluate SLAs (${{ matrix.scenario }})
        run: |
          set -eux
          SCEN=${{ matrix.scenario }}
          XML_JTL="jmeter/results/${SCEN}.xml.jtl"
          CSV_JTL="jmeter/results/${SCEN}.jtl"
          THRESH="${SLA_ERROR_PERCENT}"

          if [ -s "$XML_JTL" ]; then
            echo "Using XML JTL: $XML_JTL"
            HTTP=$(grep -o '<httpSample ' "$XML_JTL" | wc -l || true)
            SAMP=$(grep -o '<sample ' "$XML_JTL" | wc -l || true)
            TOTAL=$((HTTP + SAMP))
            FAIL_HTTP=$(grep -o '<httpSample [^>]* s="false"' "$XML_JTL" | wc -l || true)
            FAIL_SAMP=$(grep -o '<sample [^>]* s="false"' "$XML_JTL" | wc -l || true)
            FAILS=$((FAIL_HTTP + FAIL_SAMP))
          elif [ -s "$CSV_JTL" ]; then
            echo "XML not found; FALLING BACK to CSV JTL: $CSV_JTL"
            # total rows excluding header / empty lines
            TOTAL=$(grep -v '^\s*$' "$CSV_JTL" | sed '/^timeStamp,/d' | wc -l || true)
            # very generic failure count: any row containing a standalone 'false' token
            FAILS=$(grep -v '^\s*$' "$CSV_JTL" | sed '/^timeStamp,/d' | grep -E '(^|,)"?false"?($|,)' | wc -l || true)
          else
            echo "::error::Neither XML nor CSV JTL found for $SCEN."
            exit 1
          fi

          if [ "${TOTAL:-0}" -eq 0 ]; then
            echo "::error::No samples recorded for $SCEN."
            exit 1
          fi

          ERR_PCT=$(awk -v f="$FAILS" -v t="$TOTAL" 'BEGIN{printf("%.2f", (f*100)/t)}')
          echo "Scenario: $SCEN | Total: $TOTAL | Failures: $FAILS | Error%: $ERR_PCT (SLA ${THRESH}%)"

          awk -v r="$ERR_PCT" -v th="$THRESH" 'BEGIN{ if (r > th) exit 1 }' \
          || { echo "::error::Error rate ${ERR_PCT}% exceeded SLA ${THRESH}%"; exit 1; }

          echo "SLA OK."

      - name: Stop stack
        if: always()
        run: docker compose down -v
